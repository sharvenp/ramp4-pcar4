import{_ as P}from"./preload-helper-388ac9d5.js";import{s as F,iN as M,bd as N,v as b,b as S,cI as _,cp as U,cH as A,dr as G,ga as E,iO as J,iP as q,dh as z,iD as d,r as B,ct as Z,cu as y,iQ as k,cw as g,iR as p,cv as I,iS as j,iT as C}from"./main-bbf05f59.js";import{f as x,g as v}from"./projectionSupport-5e33f9f5.js";const D=new F({esriSRUnit_Meter:"meters",esriSRUnit_Kilometer:"kilometers",esriSRUnit_Foot:"feet",esriSRUnit_StatuteMile:"miles",esriSRUnit_NauticalMile:"nautical-miles",esriSRUnit_USNauticalMile:"us-nautical-miles"}),w=Object.freeze({}),h=new g,K=new g,R=new g,m={esriGeometryPoint:p,esriGeometryPolyline:I,esriGeometryPolygon:j,esriGeometryMultipoint:C};function tt(t,r,a,n=t.hasZ,e=t.hasM){if(S(r))return null;const s=t.hasZ&&n,o=t.hasM&&e;if(a){const i=y(R,r,t.hasZ,t.hasM,"esriGeometryPoint",a,n,e);return p(i,s,o)}return p(r,s,o)}function it(t,r,a,n,e,s,o=r,i=a){const c=r&&o,l=a&&i,f=B(n)?"coords"in n?n:n.geometry:null;if(S(f))return null;if(e){let u=Z(K,f,r,a,t,e,o,i);return s&&(u=y(R,u,c,l,t,s)),m[t]?.(u,c,l)??null}if(s){const u=y(R,f,r,a,t,s,o,i);return m[t]?.(u,c,l)??null}return k(h,f,r,a,o,i),m[t]?.(h,c,l)??null}async function et(t,r,a){const{outFields:n,orderByFields:e,groupByFieldsForStatistics:s,outStatistics:o}=t;if(n)for(let i=0;i<n.length;i++)n[i]=n[i].trim();if(e)for(let i=0;i<e.length;i++)e[i]=e[i].trim();if(s)for(let i=0;i<s.length;i++)s[i]=s[i].trim();if(o)for(let i=0;i<o.length;i++)o[i].onStatisticField&&(o[i].onStatisticField=o[i].onStatisticField.trim());return t.geometry&&!t.outSR&&(t.outSR=t.geometry.spatialReference),T(t,r,a)}async function T(t,r,a){if(!t)return null;let{where:n}=t;if(t.where=n=n&&n.trim(),(!n||/^1 *= *1$/.test(n)||r&&r===n)&&(t.where=null),!t.geometry)return t;let e=await H(t);if(t.distance=0,t.units=null,t.spatialRel==="esriSpatialRelEnvelopeIntersects"){const{spatialReference:s}=t.geometry;e=M(e),e.spatialReference=s}if(e){await x(e.spatialReference,a),e=V(e,a);const s=(await N(b(e)))[0];if(S(s))throw w;const o="quantizationParameters"in t&&t.quantizationParameters?.tolerance||"maxAllowableOffset"in t&&t.maxAllowableOffset||0,i=o&&$(e,a)?{densificationStep:8*o}:void 0,c=s.toJSON(),l=await v(c,c.spatialReference,a,i);if(!l)throw w;l.spatialReference=a,t.geometry=l}return t}function $(t,r){if(!t)return!1;const a=t.spatialReference;return(_(t)||U(t)||A(t))&&!G(a,r)&&!E(a,r)}function V(t,r){const a=t.spatialReference;return $(t,r)&&_(t)?{spatialReference:a,rings:[[[t.xmin,t.ymin],[t.xmin,t.ymax],[t.xmax,t.ymax],[t.xmax,t.ymin],[t.xmin,t.ymin]]]}:t}async function H(t){const{distance:r,units:a}=t,n=t.geometry;if(r==null||"vertexAttributes"in n)return n;const e=n.spatialReference,s=a?D.fromJSON(a):J(e),o=e&&(q(e)||z(e))?n:await x(e,d).then(()=>v(n,d));return(await L())(o.spatialReference,o,r,s)}async function L(){return(await P(()=>import("./geometryEngineJSON-1fb2e5fd.js"),["./geometryEngineJSON-1fb2e5fd.js","./geometryEngineBase-807394fe.js","./geometryEngineJSON-24dd3ed7.js","./json-48e3ea08.js"],import.meta.url)).geodesicBuffer}function nt(t){return t&&O in t?JSON.parse(JSON.stringify(t,Q)):t}const O="_geVersion",Q=(t,r)=>t!==O?r:void 0;export{nt as E,w as F,T as J,tt as b,it as v,et as z};
